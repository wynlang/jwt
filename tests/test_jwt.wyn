fn base64url_encode(s: string) -> string {
    return Encoding.base64_encode(s).replace_all("+", "-").replace_all("/", "_").replace_all("=", "")
}

fn jwt_header() -> string {
    return base64url_encode("{\"alg\":\"HS256\",\"typ\":\"JWT\"}")
}

fn jwt_payload(sub: string, exp: string) -> string {
    return base64url_encode("{\"sub\":\"" + sub + "\",\"exp\":" + exp + "}")
}

test "header encoded" {
    var header = jwt_header()
    assert(header.len() > 10)
}

test "payload encoded" {
    var header = jwt_header()
    var payload = jwt_payload("user123", "9999999999")
    assert(payload.len() > 10)
}

test "has dot separator" {
    var header = jwt_header()
    var payload = jwt_payload("user123", "9999999999")
    var token_body = header + "." + payload
    assert(token_body.contains("."))
}

test "signature generated" {
    var header = jwt_header()
    var payload = jwt_payload("user123", "9999999999")
    var token_body = header + "." + payload
    // Sign with HMAC-SHA256
    var sig = Crypto.hmac_sha256("secret", token_body)
    assert(sig.len() > 0)
}

test "3 parts" {
    var header = jwt_header()
    var payload = jwt_payload("user123", "9999999999")
    var token_body = header + "." + payload
    // Sign with HMAC-SHA256
    var sig = Crypto.hmac_sha256("secret", token_body)
    var token = token_body + "." + sig
    assert_eq(token.split(".").len(), 3)
}
